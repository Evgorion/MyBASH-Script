Изучаем команды Linux: sed

Оригинал: Learning Linux Commands: sed 
Автор: Rares Aioanei 
Дата публикации: 19 ноября 2011 года 
Перевод: А. Кривошей 
Дата перевода: июль 2012 г.
1. Введение
Добро пожаловать во вторую часть нашей серии, которая посвящена sed, версии GNU. Существует несколько версий sed, которые доступны на разных платформах, но мы сфокусируемся на GNU sed версии 4.x. Многие из вас слышали о sed, или уже использовали его, скорее всего в качестве инструмента замены. Но это только одно из предназначений sed, и мы постараемся показать вам все аспекты использования этой утилиты. Его название расшифровывается как "Stream EDitor" и слово "stream" (поток) в данном случае может означать файл, канал, или просто stdin. Мы надеемся, что у вас уже есть базовые знания о Linux, а если вы уже работали с регулярными выражениями, или по крайней мере знаете, что это такое, то все для вас будет намного проще. Объем статьи не позволяет включить в нее полное руководство по регулярным выражениям, вместо этого мы озвучим базовые концепции и дадим большое количество примеров использования sed.

2. Установка
Здесь не нужно много рассказывать. Скорее все sed у вас уже установлен, так как он используется различными системными скриптами, а также пользователями Linux, которые хотят повысить эффективность своей работы. Вы можете узнать, какая версия sed у вас установлена, с помощью команды:

$ sed --version
В моей системе эта команда показывает, что у меня установлен GNU sed 4.2.1 плюс дает ссылку на домашнюю страницу программы и другие полезные сведения. Пакет называется "sed" независимо от дистрибутива, кроме Gentoo, где он присутствует неявно.

3. Концепции
Перед тем, как идти дальше, мы считаем важным акцентировать внимание на том, что делает "sed", так как словосочетание "потоковый редактор" мало что говорит о его назначении. sed принимает на входе текст, выполняет заданные операции над каждой строкой (если не задано другое) и выводит модифицированный текст. Указанными операциями могут быть добавление, вставка, удаление или замена. Это не так просто, как выглядит: предупреждаю, что имеется большое количество опций и их комбинаций, которые могут сделать команду sed очень трудной для понимания. Поэтому мы рекомендуем вам изучить основы регулярных выражений, чтобы понимать, как это работает. Перед тем, как приступить к руководству, мы хотели бы поблагодарить Eric Pement и других за вдохновление и за то, что он сделал для всех, кто хочет изучать и использовать sed.

4. Регулярные выражения
Так как команды (скрипты) sed для многих остаются загадкой, мы чувствуем, что наши читатели должны понимать базовые концепции, а не слепо копировать и вставлять команды, значения которых они не понимают. Когда человек хочет понять, что представляют собой регулярные выражения, ключевым словом является "соответствие", или, точнее, "шаблон соответствия". Например, в отчете для своего департамента вы написали имя Nick, обращаясь к сетевому архитектору. Но Nick ушел, а на его место пришел John, поэтому теперь вы должны заменить слово Nick на John. Если файл с отчетом называется report.txt, вы должны выполнить следующую команду:

$ cat report.txt | sed 's/Nick/John/g' > report_new.txt
По умолчанию sed использует stdout, вы можете использовать оператор перенаправления вывода, как показано в примере выше. Это очень простой пример, но мы проиллюстрировали несколько моментов: мы ищем все соответствия шаблону "Nick" и заменяем во всех случаях на "John". Отметим, что sed призводит поиск с учетом регистра, поэтому будьте внимательны и проверьте выходной файл, чтобы убедиться, что все замены были выполнены. Приведенный выше пример можно было записать и так:

$ sed 's/Nick/John/g' report.txt > report_new.txt
Хорошо, скажете вы, но где же здесь регулярные выражения? Да, мы хотели сначала показать пример, а теперь начинается самая интересная часть.
Если вы не уверены, написали ли вы "nick" или "Nick", и хотите предусмотреть оба случая, необходимо использовать команду sed 's/Nick|nick/John/g'. Вертикальная черта имеет значение, которое вы должны знать, если изучали C, то есть ваше выражение будет соответствовать "nick" или "Nick". Как вы увидите ниже, канал может использоваться и другими способами, но смысл остается тот же самый. Другие операторы, широко использующиеся в регулярных выражениях - это "?", который соответствует повторению предшествующего символа ноль или один раз (то есть flavou?r будет соответствовать flavor и flavour), "*" - ноль или более раз, "+" - один или более раз. "^" соответствует началу строки, а "$" - наоборот. Если вы - пользователь vi или vim, многие вещи покажутся вам знакомыми. В конце концов, эти утилиты, вместе с awk и С уходят корнями в ранние дни UNIX. Мы не будем больше говорить на эту тему, так как проще понять значение этих символов на примерах, но вы должны знать, что существуют различные реализации регулярных выражений: POSIX, POSIX Extended, Perl, а также различные реализации нечетких регулярных выражений, гарантирующие вам головную боль.
